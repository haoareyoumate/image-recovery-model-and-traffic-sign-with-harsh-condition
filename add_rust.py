import cv2
import numpy as np

def interpolant(t):
    return t*t*t*(t*(t*6 - 15) + 10)

def generate_perlin_noise_2d(
        shape, res, tileable=(False, False), interpolant=interpolant
):
    """Generate a 2D numpy array of perlin noise.

    Args:
        shape: The shape of the generated array (tuple of two ints).
            This must be a multple of res.
        res: The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            res.
        tileable: If the noise should be tileable along each axis
            (tuple of two bools). Defaults to (False, False).
        interpolant: The interpolation function, defaults to
            t*t*t*(t*(t*6 - 15) + 10).

    Returns:
        A numpy array of shape shape with the generated noise.

    Raises:
        ValueError: If shape is not a multiple of res.
    """
    delta = (res[0] / shape[0], res[1] / shape[1])
    d = (shape[0] // res[0], shape[1] // res[1])
    grid = np.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]]\
             .transpose(1, 2, 0) % 1
    # Gradients
    angles = 2*np.pi*np.random.rand(res[0]+1, res[1]+1)
    gradients = np.dstack((np.cos(angles), np.sin(angles)))
    if tileable[0]:
        gradients[-1,:] = gradients[0,:]
    if tileable[1]:
        gradients[:,-1] = gradients[:,0]
    gradients = gradients.repeat(d[0], 0).repeat(d[1], 1)
    g00 = gradients[    :-d[0],    :-d[1]]
    g10 = gradients[d[0]:     ,    :-d[1]]
    g01 = gradients[    :-d[0],d[1]:     ]
    g11 = gradients[d[0]:     ,d[1]:     ]
    # Ramps
    n00 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]  )) * g00, 2)
    n10 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]  )) * g10, 2)
    n01 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]-1)) * g01, 2)
    n11 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]-1)) * g11, 2)
    # Interpolation
    t = interpolant(grid)
    n0 = n00*(1-t[:,:,0]) + t[:,:,0]*n10
    n1 = n01*(1-t[:,:,0]) + t[:,:,0]*n11
    return np.sqrt(2)*((1-t[:,:,1])*n0 + t[:,:,1]*n1)

def generate_fractal_noise_2d(
        shape, res, octaves=1, persistence=0.5,
        lacunarity=2, tileable=(False, False),
        interpolant=interpolant
):
    """Generate a 2D numpy array of fractal noise.

    Args:
        shape: The shape of the generated array (tuple of two ints).
            This must be a multiple of lacunarity**(octaves-1)*res.
        res: The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            (lacunarity**(octaves-1)*res).
        octaves: The number of octaves in the noise. Defaults to 1.
        persistence: The scaling factor between two octaves.
        lacunarity: The frequency factor between two octaves.
        tileable: If the noise should be tileable along each axis
            (tuple of two bools). Defaults to (False, False).
        interpolant: The, interpolation function, defaults to
            t*t*t*(t*(t*6 - 15) + 10).

    Returns:
        A numpy array of fractal noise and of shape shape generated by
        combining several octaves of perlin noise.

    Raises:
        ValueError: If shape is not a multiple of
            (lacunarity**(octaves-1)*res).
    """
    noise = np.zeros(shape)
    frequency = 1
    amplitude = 1
    for _ in range(octaves):
        noise += amplitude * generate_perlin_noise_2d(
            shape, (frequency*res[0], frequency*res[1]), tileable, interpolant
        )
        frequency *= lacunarity
        amplitude *= persistence
    return noise

def seg(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

    # define range of red color in HSV
    lower_red1 = np.array([0,90,90])
    upper_red1 = np.array([18,255,255])

    lower_red2 = np.array([170,90,90])
    upper_red2 = np.array([180,255,255])


    lower_blue = np.array([90,80,60])
    upper_blue = np.array([140,255,255])


    # Threshold the HSV image using inRange function to get only red colors
    mask = cv2.inRange(hsv, lower_red1, upper_red1)  | cv2.inRange(hsv, lower_red2, upper_red2)  | cv2.inRange(hsv, lower_blue, upper_blue)


    new_row = np.full((1,mask.shape[1]),0)
    new_col = np.full((mask.shape[0]+2,1),0)
    mask_flood = np.concatenate([new_row, mask, new_row],axis = 0)
    mask_flood = np.concatenate([new_col, mask_flood, new_col],axis = 1).astype(np.uint8)
    mask_flood_mask = np.zeros((mask_flood.shape[0]+2,mask_flood.shape[1]+2),np.uint8)
    cv2.floodFill(mask_flood,mask_flood_mask,(0,0),255)
    mask_flood = (255 - mask_flood)
    mask_flood = mask_flood[1:mask_flood.shape[0]-1,1:mask_flood.shape[1]-1]
    mask = mask | mask_flood
    return mask

def rust(image):
    image = cv2.resize(image,(128,128))
    y = generate_fractal_noise_2d(
            (128,128), (8,8), octaves=5, persistence=0.5,
            lacunarity=2, tileable=(False, False),
            interpolant=interpolant
    )
    y = ((y-y.min())*255/(y.max()-y.min())).astype(np.uint8)
    y[y<59] = 10
    y[ (y<110) & (y>80)] = 122
    y[(y>170) & (y<190)] = 200
    y[(y>135) & (y<150)] = y[(y>135) & (y<150)] + 8
    y[y > 230 ] = 250
    y[ (y==70) | (y == 71)] = 14

    texture_rusty = np.zeros((128,128,3),dtype=np.uint8)

    # Adjust the hue and saturation to get a rusty color scheme in hsv
    texture_rusty[:,:,0] = np.random.randint(5,15,y.shape)    # Hue
    texture_rusty[:,:,1] = np.random.randint(120,200,y.shape)  # Saturation
    texture_rusty[:,:, 2] = np.random.randint(70,100,y.shape)

    # Convert the HSV image back to BGR
    texture_rusty = cv2.cvtColor(texture_rusty, cv2.COLOR_HSV2BGR)
    noise = ((255 - y)/255).reshape((y.shape[0],y.shape[1],1))
    texture_rusty = (noise*texture_rusty).astype(np.uint8) 
    tem = seg(image)
    tem = (tem/255).reshape((128,128,1))
    image = (texture_rusty*tem + ((1-noise*tem)*image)).astype(np.uint8)
    return image

def haze(image):
    y = generate_fractal_noise_2d(
            (128,128), (4,2), octaves=5, persistence=0.5,
            lacunarity=2, tileable=(False, False),
            interpolant=interpolant
    )
    y = ((y-y.min())*0.4/(y.max()-y.min())+0.6).reshape((128,128,1))
    image = cv2.resize(image,(128,128))
    image = (0.9*y*(127+image.mean()/2) + 0.9*(1-y)*image + 0.1*image).astype(np.uint8)
    return image